<% content_for :title do %>
	<% # TODO: add in text for the research note title -%>
<% end %>

<% content_for :tags do %>
	<% # TODO: add in textual listing of new tags that this view creates -%>
<% end %>

<% content_for :data do %>
<%
	$slice = [72, 170, 178]
	$delta = 30*60
	$base = @data[0].observed_at.to_f
    
	def tick_count(position)		
		def num_ticks(n, p)
			case n
			when 0 
				return p
			else
				i = n-1
				return num_ticks(i, $slice[i]) + (@data[$slice[i]+1].observed_at.to_f-@data[$slice[i]].observed_at.to_f)/$delta + p-($slice[i]+1)+1
			end
		end
    
		if position <= $slice[0]
			num_ticks = num_ticks(0, position)
		elsif (position > $slice[0] and position <= $slice[1]) 
			num_ticks = num_ticks(1, position)
		elsif (position > $slice[1] and position <= $slice[2]) 
			num_ticks = num_ticks(2, position)
		elsif position > $slice[2] 
			num_ticks = num_ticks(3, position)
		end
		
		return num_ticks
	end

	def map_to_hash(data)
	  data.map_with_index { |d, i| { :id => d.id, :position => i, :t_host => d.observed_at.to_f, :t_ref => tick_count(i-1)*$delta+$base } }
	end
-%>
	<script>
		var raw_data = <%=raw (map_to_hash @data).to_json %>;
	</script>
<% end %>

<% content_for :note do %>
	<p>
		In this research note we use the clock description models of <%= link_to "An Improved Clock Model for Translating Timestamps", "http://www.infosec.jmu.edu/reports/jmu-infosec-tr-2007-001.php" %> (by Florian Bucholz) to build up a common time reference model.
	</p>
	<p>
		We have from the analysis of our <%= link_to "ip addresses", "/research/ip_address" %> that 10.0.1.2 and 10.0.1.14 (the IP address of our web server) are on the same subnet. The network proximity of these two IP addresses suggests that they are under the same administrative jurisdiction and so, should the need arise, we can perform additional information gathering from 10.0.1.2.
	</p>
	<p>
		From 10.0.1.2's <%= link_to "RSS accesses", "/research/web_server/rss/10.0.1.2" %>, we have that 10.0.1.2 regularly (ie. once every 27.5±1.3 minutes) sends newsfeed requests to 10.0.1.14. The regularity of these events offers us the hope that we should be able to use them to build up a clock description for 10.0.1.2. By relating that clock description to the clock source on 10.0.1.14, we should then be able to calculate a trusted reference time model for 10.0.1.14's log events.
	</p>
	<p>
		We have from 10.0.1.2's <%= link_to "agent string", "/research/by?ip_address=10.0.1.2" %> (we have here used <%= link_to "user-agent-string.info" %> to interpret browser agent strings) that 10.0.1.2 is running OS X 10.6.2 along with the following browsers:
		<ul>
			<li>Firefox 3.6.3</li>
			<li>Safari 4.0.5.</li>
		</ul>
		By default on OS X (these conclusions have been determined by inspecting vanilla copies of Mail.app, Firefox and Safari - the most common RSS clients within OS X):
		<ul>
			<li>Firefox fetches live bookmarks (ie. RSS newsfeeds) ever 60 minutes</li>
			<li>Mail.app defaults to updating every 30 minutes</li>
			<li>and Safari defaults to every 30 minutes.</li>
		</ul>
		Given that our RSS requests are estimated as being generated every 27.5±1.3 minutes, then RSS newsfeed clients are probably scheduled to be update every 30 minutes.
	</p>
	<p>
		Regardless of RSS client, newsfeed HTTP requests are here generated using Apple's PubSub agent. This agent is ran regularly via launchd (a cron-like replacement). Thus, by performing additional experiments on 10.0.1.2 (see below), we may then generate an estimate for the accuracy of using launchd as a model of clock ticks.
	</p>
	<p>		
		The 10.0.1.14 log event timestamp is generated by 10.0.1.14's system clock when the log event is received (according to <%= link_to "Capturing Timestamp Precision for Digital Forensics", "http://www.infosec.jmu.edu/reports/jmu-infosec-tr-2009-002.pdf" %> by Eugene Antsilevich, this is achieved via a call to <code>gettimeofday()</code>). This timestamp represents the time at which 10.0.1.14 received the RSS request from 10.0.1.2. The accuracy of this timestamp (relative to real time) is related to:
		<ul>
			<li>accuracy of launchd in triggering RSS HTTP update events</li>
			<li>and network latency.</li>
		</ul>
		The network proximity of 10.0.1.2 and 10.0.1.14 suggests that network latency should essentially be a constant. Thus, our timestamp accuracy boils down to the timing accuracy of launchd.
		
		TODO: add in 10.0.1.2 experiment details. FIXME: add in library scraped data about the time functions launchd uses.
	</p>
	<p>
		For each RSS request (say request number n &ge; 0), let t<sub>ref</sub>(n) be the time determined using 10.0.1.2's clock. Due to the periodicity of 10.0.1.2's newsfeed requests we can represent this time via the equation:
		<center>
			t<sub>ref</sub>(n) = t<sub>offset</sub> + &delta; &times; n
		</center>
		where &delta; is the periodicity with which these RSS requests are generated (using the analysis above, we shall take this value to be 30 minutes) and t<sub>offset</sub> is a starting, base or offset time value. In addition, we have that this time is equivalent to the newsfeed's recorded timestamp t<sub>host</sub>(n).
	</p>
	<p>
		In the absence of any further clock data for 10.0.1.2, we choose to fix t<sub>offset</sub> to be t<sub>host</sub>(0). We may now build the following clock reference model for 10.0.1.14:
	</p>
	
	<% # TODO: document t_ref calculation/function -%>
	
	<h3>t_ref vs (t_host-t_ref)</h3>
    
	<script type="text/javascript+protovis">
		var data = raw_data.map(function(d) { h = {}; h['position'] = d.position; h['t_host'] = d.t_host; h['x'] = d.t_ref; h['y'] = d.t_host-d.t_ref; return h; });
		
		<%= render :partial => '/graph/area.js' %>
		
		xlabel.text(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d*1000)));
		ylabel.text(function(d) (d)+" s");
		area.title(function(d) "{ position: "+d.position+", t_ref: "+pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d['x']*1000))+", t_host: "+pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d['t_host']*1000))+", t_host-t_ref: "+d['y']+"s }");
		
		vis.render();
	</script>
	
	<p>
		Based upon this graph, we can now estimate 10.0.1.14's clock skew as being ?? and offer to explain 10.0.1.2's refresh gaps as follows:
		<ul>
			<li>from 02:36:16 to 19:34:16 (21/Apr/2010), 10.0.1.2 was probably offline and 10.0.1.14 had no discernible time modifications applied</li>
			<li>from 20:04:16 to 21:32:19 (23/Apr/2010), 10.0.1.14 had a <%= number_with_precision (@data[$slice[1]+1].observed_at.to_f - (tick_count($slice[1]+1)*$delta+$base))/(60*60), :precision => 1 %> hour time modification applied</li>
			<li>from 01:02:19 to 02:53:57 (24/Apr/2010), 10.0.1.14 had a <%= number_with_precision (@data[$slice[2]+1].observed_at.to_f - (tick_count($slice[2]+1)*$delta+$base))/(60*60), :precision => 1 %> hour time modification applied.</li>
		</ul>
	</p>
<% end %>
