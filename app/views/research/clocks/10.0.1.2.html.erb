<% content_for :title do %>
	Clock Description for 10.0.1.14
<% end %>

<% content_for :tags do %>
	<% # TODO: add in textual listing of new tags that this view creates -%>
<% end %>

<% content_for :data do %>
<%
	$slice = [72, 170, 178]
	$delta = 30*60
	$base = @data[0].observed_at.to_f
    
	def tick_count(position)		
		def num_ticks(n, p)
			case n
			when 0 
				return p
			else
				i = n-1
				return num_ticks(i, $slice[i]) + (@data[$slice[i]+1].observed_at.to_f-@data[$slice[i]].observed_at.to_f)/$delta + p-($slice[i]+1)+1
			end
		end
    
		if position <= $slice[0]
			num_ticks = num_ticks(0, position)
		elsif (position > $slice[0] and position <= $slice[1]) 
			num_ticks = num_ticks(1, position)
		elsif (position > $slice[1] and position <= $slice[2]) 
			num_ticks = num_ticks(2, position)
		elsif position > $slice[2] 
			num_ticks = num_ticks(3, position)
		end
		
		return num_ticks
	end

	def map_to_hash(data)
	  data.map_with_index { |d, i| { :id => d.id, :position => i, :t_host => d.observed_at.to_f, :t_ref => tick_count(i-1)*$delta+$base } }
	end
-%>
	<script>
		var raw_data = <%=raw (map_to_hash @data).to_json %>;
	</script>
<% end %>

<% content_for :note do %>
	<p>
		In this research note we use the clock description models of <%= link_to "An Improved Clock Model for Translating Timestamps", "http://www.infosec.jmu.edu/reports/jmu-infosec-tr-2007-001.php" %> (by Florian Bucholz) to build up a common time reference model.
	</p>
	<p>
		We have from the analysis of our <%= link_to "ip addresses", "/research/ip_address" %> that 10.0.1.2 and 10.0.1.14 (the IP address of our web server) are on the same subnet. The network proximity of these two IP addresses suggests that they are under the same administrative jurisdiction and so, should the need arise, we can perform additional information gathering from 10.0.1.2.
	</p>
	<p>
		From 10.0.1.2's <%= link_to "RSS accesses", "/research/web_server/rss/10.0.1.2" %>, we have that 10.0.1.2 regularly (ie. once every 27.5±1.3 minutes) sends newsfeed requests to 10.0.1.14. The regularity of these events offers us the hope that we should be able to use them to build up a clock description for 10.0.1.2. By relating that clock description to the clock source on 10.0.1.14, we should then be able to calculate a trusted reference time model for 10.0.1.14's log events.
	</p>
	<p>
		We have from 10.0.1.2's <%= link_to "agent string", "/research/by?ip_address=10.0.1.2" %> (we have here used <%= link_to "user-agent-string.info" %> to interpret browser agent strings) that 10.0.1.2 is running OS X 10.6.2 along with the following browsers:
		<ul>
			<li>Firefox 3.6.3</li>
			<li>Safari 4.0.5.</li>
		</ul>
		By default on OS X (these conclusions have been determined by inspecting vanilla copies of Mail.app, Firefox and Safari - the most common RSS clients within OS X):
		<ul>
			<li>Firefox fetches live bookmarks (ie. RSS newsfeeds) ever 60 minutes</li>
			<li>Mail.app defaults to updating every 30 minutes</li>
			<li>and Safari defaults to every 30 minutes.</li>
		</ul>
		Given that our RSS requests are estimated as being generated every 27.5±1.3 minutes, then RSS newsfeed clients are probably scheduled to be update every 30 minutes.
	</p>
	<p>
		Regardless of RSS client, newsfeed HTTP requests are here generated using Apple's PubSub agent. This agent is ran regularly via launchd (a cron-like replacement). Thus, by performing additional experiments on 10.0.1.2 (see below), we may then generate an estimate for the accuracy of using launchd as a model of clock ticks.
	</p>
	<p>		
		The 10.0.1.14 log event timestamp is generated by 10.0.1.14's system clock when the log event is received (according to <%= link_to "Capturing Timestamp Precision for Digital Forensics", "http://www.infosec.jmu.edu/reports/jmu-infosec-tr-2009-002.pdf" %> by Eugene Antsilevich, this is achieved via a call to <code>gettimeofday()</code>). This timestamp represents the time at which 10.0.1.14 received the RSS request from 10.0.1.2. The accuracy of this timestamp (relative to real time) is related to:
		<ul>
			<li>accuracy of launchd in triggering RSS HTTP update events</li>
			<li>and network latency.</li>
		</ul>
		The network proximity of 10.0.1.2 and 10.0.1.14 suggests that network latency should essentially be a constant. Thus, our timestamp accuracy boils down to the timing accuracy of launchd.
		
		TODO: add in 10.0.1.2 experiment details. FIXME: add in library scraped data about the time functions launchd uses.
	</p>
	<p>
		For each RSS request (say request number n &ge; 0), let t<sub>ref</sub>(n) be the time determined using 10.0.1.2's clock. Due to the periodicity of 10.0.1.2's newsfeed requests we can represent this time via the equation:
		<center>
			t<sub>ref</sub>(n) = t<sub>offset</sub> + &delta; &times; n
		</center>
		where &delta; is the periodicity with which these RSS requests are generated (using the analysis above, we shall take this value to be 30 minutes) and t<sub>offset</sub> is a starting, base or offset time value. In addition, we have that this time is equivalent to the newsfeed's recorded timestamp t<sub>host</sub>(n).
	</p>
	<p>
		In the absence of any further clock data for 10.0.1.2, we choose to fix t<sub>offset</sub> to be t<sub>host</sub>(0). We may now build a clock reference model for 10.0.1.14 by estimating its clock ticks as follows:
		<ul>
			<li>over the period ?? (UTC) until ?? (UTC), we have that t<sub>ref</sub>'s clock ticks correspond precisely with the order of 10.0.1.2 RSS logging events</li>
			<li>by trusting 10.0.1.14 to accurately measure time duration and assuming that 10.0.1.2 generates an RSS request every 30 minutes, we can estimate how many clock ticks have occurred during each of our RSS refresh gaps.</li>
		</ul>
		As a result of these considerations, we may now implement a function that calculates how many 10.0.1.2 clock ticks have occurred since t<sub>host</sub>(0). Using this function, we can now plot the following graph:
	</p>
	
	<h3>t<sub>ref</sub> vs t<sub>host</sub></h3>
    
	<script type="text/javascript+protovis">
		var data = raw_data.map(function(d) { h = {}; h['position'] = d.position; h['t_host'] = d.t_host; h['x'] = d.t_ref; h['y'] = d.t_host; return h; });
		
		<%= render :partial => '/graph/area.js' %>
		
		xlabel.text(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d*1000)));
		ylabel.text(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d*1000)));
		area.title(function(d) "{ position: "+d.position+", t_ref: "+pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d.x*1000))+", t_host: "+pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d.y*1000))+" }");
		
		vis.add(pv.Line)
			.data([{ x:data.first().x, y:data.first().x }, { x:data.last().x, y:data.last().x }])
			.bottom(function(d) y(d.y))
			.left(function(d) x(d.x))
			.lineWidth(1)
			.strokeStyle("#FF2D26");
		
		vis.render();
	</script>
	<p>
		<b>Note:</b> the <font color="#ff2d26">red</font> line in the above graph represents the equation y=x and describes the curve that should be followed in the case where 10.0.1.14 has its clock precisely synchronised with the reference clock on 10.0.1.2.
	</p>
	<p>
		Using this graph we can see that 10.0.1.14 (ie. t<sub>host</sub>) has its clock set behind our reference clock on 10.0.1.2 (ie. t<sub>ref</sub>). By measuring the rate of change of the difference in times (between 10.0.1.2 and 10.0.1.14), we may estimate 10.0.1.14's clock skew (see graph below). 
	</p>
	<p>
		Looking at the graph above, we can also see that for every day, 10.0.1.2's clock drifts from our reference model (ie. t<sub>ref</sub>) by approximately 1 hour. Thus we see that, for the data we are examining, clock skew is significant!
	</p>
	
	<h3>t<sub>ref</sub> vs (t<sub>host</sub>-t<sub>ref</sub>)</h3>
    
	<script type="text/javascript+protovis">
		var data = raw_data.map(function(d) { h = {}; h['position'] = d.position; h['t_host'] = d.t_host; h['x'] = d.t_ref; h['y'] = d.t_host-d.t_ref; return h; });
		
		<%= render :partial => '/graph/area.js' %>
		
		xlabel.text(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d*1000)));
		ylabel.text(function(d) (d)+" s");
		area.title(function(d) "{ position: "+d.position+", t_ref: "+pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d['x']*1000))+", t_host: "+pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d['t_host']*1000))+", t_host-t_ref: "+d['y']+"s }");
		
		//vis.add(pv.Line)
		//	.data([{ x:data.first().x, y:1145.31327 }, { x:data.last().x, y:-21841.67397 }])
		//	.bottom(function(d) y(d.y))
		//	.left(function(d) x(d.x))
		//	.lineWidth(1)
		//	.strokeStyle("#FF2D26");
		
		vis.render();
	</script>
	<% # TODO: add in CSV link for downloading graph data for use in R -%>
	<p>
		From <%= link_to "An Improved Clock Model for Translating Timestamps", "http://www.infosec.jmu.edu/reports/jmu-infosec-tr-2007-001.php" %> (by Florian Bucholz), we have that clock skews are generally linear. As a result, we use a least squares approximation to build a linear model describing 10.0.1.14's clock. Before we may export this graph data into the R framework, we normalise our RSS refresh gaps as follows:
		<ul>
			<li>??</li>
		</ul>
		Using this normalised data within the R framework we are able to estimate 10.0.1.14's clock skew (ie. the graphs gradient) to be -0.04651 (with a y-axis intersect of 59140000).
	</p>
	<p>
		The result of this analysis has been drawn in <font color="#ff2d26">red</font> on the graph above.
	</p>
	<p>
		Based upon this linear regression model, we can now estimate 10.0.1.14's clock skew as being ?? and offer to explain 10.0.1.2's refresh gaps as follows:
		<ul>
			<li>from 02:36:16 to 19:34:16 (21/Apr/2010 UTC), 10.0.1.2 was probably offline and 10.0.1.14 had no discernible time modifications applied</li>
			<li>from 20:04:16 to 21:32:19 (23/Apr/2010 UTC), 10.0.1.14 had a <%= number_with_precision (@data[$slice[1]+1].observed_at.to_f - (tick_count($slice[1]+1)*$delta+$base))/(60*60), :precision => 1 %> hour time modification applied</li>
			<li>from 01:02:19 to 02:53:57 (24/Apr/2010 UTC), 10.0.1.14 had a <%= number_with_precision (@data[$slice[2]+1].observed_at.to_f - (tick_count($slice[2]+1)*$delta+$base))/(60*60), :precision => 1 %> hour time modification applied.</li>
		</ul>
	</p>
	<% # TODO: tag events that fall within time modification windows -%>
<% end %>
