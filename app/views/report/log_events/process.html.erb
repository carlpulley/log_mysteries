<h1>Log Event Analysis of <i>unknown</i> Attribute</h1>

<h2>Overview</h2>

<p>By analysing the <i>unknown</i> attribute we are able to determine that:
	<ul>
		<li>the version of Apache2 installed is at revision number 420893 or below</li>
		<li>mod_unique_id is installed and enabled on the server</li>
		<li>for each log entry we can assert the process ID and thread index that dealt with the request</li>
		<li>one log event at time index 19/Apr/2010:11:19:21 -0700 in www-media.log fails to match the timestamp value of the <i>unknown</i> attribute</li>
	</ul>
</p>

<h2>Detailed Analysis</h2>

<p>From our scatter plot of observation time vs process ID, we may determine when the server was restarted. We may achieve this by exploiting the behaviour of Apache.</p>

<p>When Apache starts up, it reserves a series of worker processes for itself. As these processes are typically all created at the same time they often have sequential process IDs. Over time, these worker processes are reused to process different sets of incoming requests. Over time, any Apache restarts can be detected as the process ID's will cluster into groups (see the graph below).</p>

<p>Across server restarts, we might expect that the same group of process IDs are allocated as the Apache process is likely to be started at around the same point in the init process each time.</p>

<p>Apache keeps track of its worker processes by using a data structure known as a thread index. By plotting these against time as well, we should be able to see clear patterns of process restarts.</p>

<p>Vertical or diagonal tending lines indicate increasing numbers of worker threads being utilised to process incoming HTTP requests as the Apache server process starts up and so are features consistent with a process restart.</p>

<p>Horizontal lines can be grouped based on thread index - each thread index being assigned to process an incoming HTTP request.</p>

<h3>Scatter Plot of Observed Time (seconds from epoch) vs Process ID vs Observed Time (seconds from epoch on a blue to red scale)</h3>

<script type="text/javascript+protovis">
	var data = <%=raw @log_events.all.map { |d| { :y => d.pid, :x => d.observed_at.to_i, :z => d.observed_at.to_i } }.to_json %>;
	
	<%= render :partial => '/graph/scatter.js' %>
	
	xlabel.text(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d*1000)));
	dot.title(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d.z*1000)));
	
	vis.render();
</script>

<h3>Scatter Plot of Thread Index vs Process ID vs Observed Time (seconds from epoch on a blue to red scale)</h3>

<script type="text/javascript+protovis">
	var data = <%=raw @log_events.all.map { |d| { :y => d.pid, :z => d.observed_at.to_i, :x => (d.thread_index || 0) } }.to_json %>;
	
	<%= render :partial => '/graph/scatter.js' %>

	dot.title(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d.z*1000)));
	
	vis.render();
</script>

<h3>Scatter Plot of Process ID vs Counter vs Observed Time (seconds from epoch on a blue to red scale)</h3>

<script type="text/javascript+protovis">
	var data = <%=raw @log_events.all.map { |d| { :y => d.counter, :z => d.observed_at.to_i, :x => d.pid } }.to_json %>;
	
	<%= render :partial => '/graph/scatter.js' %>

	dot.title(function(d) pv.Format.date("%d/%b/%y %H:%M:%S")(new Date(d.z*1000)));
	
	vis.render();
</script>

<h3>Process ID Timeline</h3>

<% data = [] %>
<% @log_events.all.map { |d| d.pid }.compact.uniq.sort.each do |pid| %>
	<% data << { :label => "PID: #{pid}", :timeline => @log_events.all.select { |d| d.pid == pid }.map { |d| { :begin => d.observed_at.to_f, :end => d.observed_at.to_f+(d.processing_time.to_f/(10**6)) } } } %>
<% end %>
<% data << { :label => "Apache2 Start Times", :timeline => Sudo.apache_timeline_starts } %>
<% data << { :label => "Apache2 Stop Times", :timeline => Sudo.apache_timeline_ends } %>
<script type="text/javascript+protovis">
	var data = <%=raw data.to_json %>;

	<%= render :partial => '/graph/timeline.js' %>

	vis.render();
</script>

<h2>Appendix</h2>

<%= link_to "Data Set (CSV)", "/research/by.csv?#{params.keys.select { |k| ["ip_address", "user_agent", "tagged"].member? k }.map { |k| [k, params[k]].join("=") }.join("&") }" %>
